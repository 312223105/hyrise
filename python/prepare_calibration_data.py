# This script is used to join and clean the calibration data for use in the 'cost_models' script
# It takes the directory of the four .csv files that are generated by the cost calibration run on hyrise as an argument

import json
import os
import pandas as pd

def parse_csv_meta(file_name):
    data_types = {'int': 'int', 'long': 'int', 'string': 'str'}
    with open(file_name) as f:
        csv_meta = json.loads(f.read())
        headers = [column['name'] for column in csv_meta['columns']]
        config = csv_meta['config']
        return (headers, config['separator'])


def parse_hyrise_csv(file_name):
    headers, separator = parse_csv_meta(f'{file_name}.json')
    return pd.read_csv(file_name, sep=separator, names=headers)


def import_train_data(path):
    operator_data = parse_hyrise_csv(os.path.join(path, 'operators.csv'))
    table_scan_data = operator_data[operator_data['OPERATOR_NAME'] == 'TableScan']
    column_filter = filter(lambda column: column not in ['OPERATOR_NAME', 'INPUT_ROWS_RIGHT'],
                           table_scan_data.columns.values.tolist())
    filtered_header = [column_name for column_name in column_filter]

    table_scan_data = table_scan_data.filter(items=filtered_header)
    table_data = parse_hyrise_csv(os.path.join(path, 'table_meta.csv'))
    columns_data = parse_hyrise_csv(os.path.join(path, 'column_meta.csv'))
    chunk_meta = parse_hyrise_csv(os.path.join(path, 'segment_meta.csv'))

    joined_data = table_scan_data.merge(table_data, on=['TABLE_NAME'], how='left')
    joined_data = joined_data.merge(columns_data, on=['TABLE_NAME', 'COLUMN_NAME'], how='left')

    # only look at the encoding of the first chunk
    chunkrows = chunk_meta.loc[(chunk_meta['CHUNK_ID'] == 0)]
    joined_data = joined_data.merge(chunkrows, on=['TABLE_NAME', 'COLUMN_NAME'], how='left')

    joined_data = joined_data.rename(columns={'INPUT_ROWS_LEFT': 'INPUT_ROWS', 'CHUNK_SIZE': 'MAX_CHUNK_SIZE',
                                              'COLUMN_DATA_TYPE': 'DATA_TYPE', 'ENCODING_TYPE': 'ENCODING',
                                              'OPERATOR_IMPLEMENTATION': 'SCAN_IMPLEMENTATION', 'OPERATOR_DETAIL': 'SCAN_TYPE'})

    # remove the rows with ExpressionEvaluator queries from the test data since we don't have any in the test data
    joined_data = joined_data.loc[(joined_data['SCAN_IMPLEMENTATION'] != 'ExpressionEvaluator')]

# explicitly add selectivity
    joined_data['SELECTIVITY'] = (joined_data['OUTPUT_ROWS'] / joined_data['INPUT_ROWS'])
    joined_data['SELECTIVITY'].fillna(0, inplace=True)
    return joined_data
